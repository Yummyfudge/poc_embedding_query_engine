-- ============================================================
-- pdf_to_parse_poc â€” DB objects up through chunking (MVP)
-- ============================================================
--
-- PURPOSE
--   This single SQL file captures everything needed to run the
--   project up through the "chunking" step:
--     - schema
--     - tables: pdf_document, pdf_page, pdf_page_chunk
--     - indexes
--     - grants/permissions for joe_admin
--
-- EXECUTION NOTES
--   - Run this file as the table owner / superuser (joe_dba).
--   - Re-runnable / idempotent where practical (IF NOT EXISTS).
--   - This file intentionally avoids data manipulation (no INSERTs).
--
-- ORDERING
--   1) Schema
--   2) Core tables + FK relationships
--   3) Optional additive columns (refined_metadata)
--   4) Indexes
--   5) Grants
--
-- FUTURE SPLIT (recommended)
--   Once stabilized, split into:
--     001_schema.sql
--     010_tables_core.sql
--     020_tables_refinement.sql
--     030_tables_chunking.sql
--     090_grants.sql
-- ============================================================

BEGIN;

-- ------------------------------------------------------------
-- 1) Schema
-- ------------------------------------------------------------
CREATE SCHEMA IF NOT EXISTS pdf_emergency;
COMMENT ON SCHEMA pdf_emergency IS
  'Emergency PDF intake/indexing POC. Stores metadata only; page/chunk text lives on disk.';

-- ------------------------------------------------------------
-- 2) Core tables
-- ------------------------------------------------------------

-- 2.1) One row per PDF source document
CREATE TABLE IF NOT EXISTS pdf_emergency.pdf_document (
    document_id UUID PRIMARY KEY,
    source_filename TEXT NOT NULL,
    source_path TEXT NOT NULL,
    page_count INTEGER NOT NULL,
    created_at_utc TIMESTAMPTZ NOT NULL DEFAULT now()
);

COMMENT ON TABLE pdf_emergency.pdf_document IS
  'One row per source PDF. document_id is generated by Python.';

-- 2.2) One row per page (metadata only)
CREATE TABLE IF NOT EXISTS pdf_emergency.pdf_page (
    document_id UUID NOT NULL
        REFERENCES pdf_emergency.pdf_document(document_id)
        ON DELETE CASCADE,

    page_number INTEGER NOT NULL,

    text_path TEXT NOT NULL,
    text_sha256 TEXT NOT NULL,
    char_count INTEGER NOT NULL,

    has_unreadable_content BOOLEAN NOT NULL DEFAULT FALSE,
    extraction_warning TEXT NULL,

    needs_ocr BOOLEAN NOT NULL DEFAULT FALSE,
    ocr_completed BOOLEAN NOT NULL DEFAULT FALSE,

    created_at_utc TIMESTAMPTZ NOT NULL DEFAULT now(),

    PRIMARY KEY (document_id, page_number)
);

COMMENT ON TABLE pdf_emergency.pdf_page IS
  'Page-level extraction metadata. Text is written to disk; DB stores paths/hashes/flags.';

-- ------------------------------------------------------------
-- 3) Refinement support (additive column)
-- ------------------------------------------------------------
-- NOTE: This column is added by scripts/refine_pages.py. It requires
-- table ownership (ALTER TABLE). Keeping it here prevents privilege
-- surprises for joe_admin.
ALTER TABLE pdf_emergency.pdf_page
  ADD COLUMN IF NOT EXISTS refined_metadata JSONB;

COMMENT ON COLUMN pdf_emergency.pdf_page.refined_metadata IS
  'Derived signals computed from page text (flags, first_line, year counts, densities, etc.).';

-- ------------------------------------------------------------
-- 4) Chunking table
-- ------------------------------------------------------------
-- NOTE: Chunk text is written to disk; DB stores chunk identity and offsets.
CREATE TABLE IF NOT EXISTS pdf_emergency.pdf_page_chunk (
  chunk_id UUID PRIMARY KEY,

  document_id UUID NOT NULL
    REFERENCES pdf_emergency.pdf_document(document_id)
    ON DELETE CASCADE,

  page_number INTEGER NOT NULL,
  chunk_index INTEGER NOT NULL,

  -- Character offsets relative to the *page text file* (post-cleanup).
  -- These allow traceability back to the exact region of the page text.
  char_start INTEGER NOT NULL,
  char_end INTEGER NOT NULL,

  -- Approx token estimate used for chunk sizing (MVP uses chars/4).
  token_estimate INTEGER NOT NULL,

  chunk_text_path TEXT NOT NULL,
  text_sha256 TEXT NOT NULL,

  created_at_utc TIMESTAMPTZ NOT NULL DEFAULT now(),

  UNIQUE (document_id, page_number, chunk_index)
);

COMMENT ON TABLE pdf_emergency.pdf_page_chunk IS
  'Chunk registry for semantic search. Chunk text lives on disk; DB stores identifiers and offsets.';

-- ------------------------------------------------------------
-- 5) Indexes
-- ------------------------------------------------------------

-- Pages
CREATE INDEX IF NOT EXISTS idx_pdf_page_document
    ON pdf_emergency.pdf_page (document_id);

CREATE INDEX IF NOT EXISTS idx_pdf_page_flags
    ON pdf_emergency.pdf_page (needs_ocr, has_unreadable_content);

-- Chunks
CREATE INDEX IF NOT EXISTS idx_pdf_page_chunk_doc
  ON pdf_emergency.pdf_page_chunk (document_id, page_number);

CREATE INDEX IF NOT EXISTS idx_pdf_page_chunk_chunkid
  ON pdf_emergency.pdf_page_chunk (chunk_id);

-- Optional: if you expect to query refined_metadata frequently,
-- consider a GIN index later. Not needed for MVP.
-- CREATE INDEX IF NOT EXISTS idx_pdf_page_refined_metadata_gin
--   ON pdf_emergency.pdf_page USING gin (refined_metadata);

-- ------------------------------------------------------------
-- 6) Grants / permissions
-- ------------------------------------------------------------
-- NOTE: These grants assume roles already exist:
--   - joe_dba (superuser/owner running this script)
--   - joe_admin (pipeline user for DML operations)

GRANT USAGE ON SCHEMA pdf_emergency TO joe_admin;

GRANT SELECT, INSERT, UPDATE, DELETE
ON pdf_emergency.pdf_document
TO joe_admin;

GRANT SELECT, INSERT, UPDATE, DELETE
ON pdf_emergency.pdf_page
TO joe_admin;

GRANT SELECT, INSERT, UPDATE, DELETE
ON pdf_emergency.pdf_page_chunk
TO joe_admin;

COMMIT;

-- ============================================================
-- END
-- ============================================================
